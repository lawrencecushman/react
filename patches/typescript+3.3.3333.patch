diff --git a/node_modules/typescript/lib/typescript.js b/node_modules/typescript/lib/typescript.js
index d2e2e7e..3578c8f 100644
--- a/node_modules/typescript/lib/typescript.js
+++ b/node_modules/typescript/lib/typescript.js
@@ -41795,6 +41795,8 @@ var ts;
             var overflow = false;
             var suppressNextError = false;
             ts.Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking");
+
+            console.log('--> relation', relation)
             var result = isRelatedTo(source, target, /*reportErrors*/ !!errorNode, headMessage);
             if (overflow) {
                 error(errorNode, ts.Diagnostics.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));
@@ -42342,12 +42344,50 @@ var ts;
                 }
                 return result;
             }
+
+            function getTypeNameOf(source) {
+                var c = !!(source && source.symbol)
+                if (!c) return null
+
+                return source.symbol.escapedName
+            }
+
+            function getFileOf(source) {
+                var c = !!(source && source.symbol && source.symbol.valueDeclaration)
+                if (!c) { return null }
+
+                var current = source.symbol.valueDeclaration
+                while (current) {
+                    if (current.fileName) {
+                        return current.fileName
+                    }
+
+                    current = current.parent
+                }
+
+                return null
+            }
+
+            function getPositionOf(source) {
+                var c = !!(source && source.symbol && source.symbol.valueDeclaration)
+                if (!c) return null
+
+                return source.symbol.valueDeclaration.pos
+            }
+
+            function getDescriptionOf(source) {
+                return `${getTypeNameOf(source)} in ${getFileOf(source)}:${getPositionOf(source)}`
+            }
+
             // Determine if possibly recursive types are related. First, check if the result is already available in the global cache.
             // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
             // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
             // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
             // and issue an error. Otherwise, actually compare the structure of the two types.
             function recursiveTypeRelatedTo(source, target, reportErrors, isIntersectionConstituent) {
+                if (source && source.symbol && source.symbol.escapedName && target && target.symbol && target.symbol.escapedName) {
+                    console.log(`${getDescriptionOf(source)} => ${getDescriptionOf(target)}`)
+                }
                 if (overflow) {
                     return 0 /* False */;
                 }
